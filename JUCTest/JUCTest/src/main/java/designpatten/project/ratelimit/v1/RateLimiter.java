package designpatten.project.ratelimit.v1;

/**
 * @ClassName: RateLimiter
 * @Description: V1版本的限流
 * 需求分析：
 *
 *  限流规则：
 *    如何定义：
 *      内容格式：如何写规则（1s内100次上限？）
 *      文件格式：xml、yaml
 *      数据源：配置中心、zk、文本文件（参考Spring的约定大于配置，约定文件名称、文件放置的位置）
 *
 *  限流算法：
 *    固定时间窗口限流算法：
 *      这个最简单，但是有bug。比如：第一秒内的后20ms，出现了100次请求。第二秒的前10ms内，出现了100次请求。
 *      那么这30ms内出现了200次请求，按道理应该被限制住的，但是这个算法限制不住。
 *
 *    滑动时间窗口限流算法：
 *
 *    令牌桶限流算法：
 *
 *    漏桶限流算法：
 *
 *
 *  限流模式：
 *    单机限流算法（单实例，一个机器可以多个实例）：对某个接口，单实例不能超过限制值
 *
 *    分布式限流算法（基于redis等）：对某个接口，部署的N个实例，加起来不能超过限制值
 *
 *  非功能性需求：
 *    易用性：配置简单、使用简单、非常方便集成到Spring中（类似MyBatis-Spring，我们可以做成RateLimiter-Spring类库）
 *
 *    扩展性：能够扩展不同的限流算法、不同的格式、不同的数据源。
 *
 *    灵活性：能够扩展不同的限流算法、不同的格式、不同的数据源。
 *
 *    性能：  接口限流逻辑低延迟，不能影响接口本身的响应时间。
 *
 *    容错性：不能因为限流框架的异常影响到接口的可用性。（分布式限流算法，如果redis挂了，业务需要能正常运行）
 *      redis：
 *        1.redis本身异常（捕获封装异常，向上抛或者吞掉）
 *        2.网络超时：需要设置redis访问超时时间，时间大小要合适（根据压测或者线上监控情况来设置），大了影响接口响应时间，小了影响限流的效果。
 *
 * @Author: xiahaitao
 * @Date: 2024/2/8 16:27
 * @Version: V1.0
 */
public class RateLimiter {
    //1.提供把配置解析成类的方法
    public RateRule parseRule(){
        //1.如果是yaml文件，从固定位置读取，然后进行解析
      RateRule rule = parseRuleFromYaml();
      return rule;
    }
    //2.根据配置类，进行规则判断。这属于是算法的范畴了。
}
